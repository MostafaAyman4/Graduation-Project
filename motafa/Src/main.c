/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#include "STD_TYPES.h"
#include "BIT_MATH.h"

#include "RCC_interface.h"
#include "MSYSTICK_interface.h"
#include "DIO_interface.h"
//#include "DIO_private.h"
#include "GENRERALTIMERS_interface.h"
//#include "GENRERALTIMERS_private.h"
#include "MNVIC_interface.h"
//#include "UART_interface.h"
//#include "SPI_interface.h"
/*#include "EXTI_interface.h"
#include "AFIO_interface.h"


#include "MDMA_interface.h"
#include "MGENTIMERS_private.h"
*/
//#include "MNVIC_interface.h"


#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif
int state=0;
int main(void)
{
	MRCC_voidInitClock();
	MRCC_voidEnableClock(RCC_APB1,TIM2_EN);
	MTimer_voidInitInputCapture(TIMER_2,CHANNEL_1);

	//MDMA_voidInitChannel(CHANNEL_1,0x40010800,0x40010500,1,VERY_HIGH,READ_FROM_PERIPHERAL,CIRCULAR_DISABLE,INC_DISABLE,INC_DISABLE,PER_BITS_32,MEM_BITS_32,INC_ENABLE,INC_DISABLE,INC_DISABLE);
		//MDMA_voidEnableChannel(CHANNEL_1);
		//MDMA_voidDisableChannel(CHANNEL_1);
		/*
		MNVIC_voidEnableInterrupt(EXTI0_INT_NO);
		MNVIC_voidDisableInterrupt(EXTI0_INT_NO);
		MNVIC_voidSetPendingFlag(EXTI0_INT_NO);
		MNVIC_voidClearPendingFlag(EXTI0_INT_NO);
		MNVIC_uint8GetActiveFlag(EXTI0_INT_NO);
		MNVIC_voidSetPeriorty(EXTI0_INT_NO,0,1);
		MDIO_INIT(PORTA);
		for(int i=0;i<16;i++){
			MDIO_voidSetDirection(PORTA ,i ,OUTPUT_10MHZ_PUSH_PULL);
			MDIO_voidWrite_D_pin(PORTA , i ,LOW);
		}
		MDIO_INIT(PORTB);
			for(int i=0;i<16;i++){
				MDIO_voidSetDirection(PORTB ,i ,OUTPUT_10MHZ_PUSH_PULL);
				MDIO_voidWrite_D_pin(PORTB, i ,HIGH);
			}
		MDIO_INIT(PORTC);
		MDIO_voidSetDirection(PORTC ,15 ,OUTPUT_10MHZ_PUSH_PULL);
		MDIO_voidWrite_D_pin(PORTC , 15 ,LOW);
		MDIO_voidSetDirection(PORTC ,13 ,OUTPUT_10MHZ_PUSH_PULL);
		MDIO_voidWrite_D_pin(PORTC , 13 ,LOW);
		MDIO_voidSetDirection(PORTC ,14 ,OUTPUT_10MHZ_PUSH_PULL);
		MDIO_voidWrite_D_pin(PORTC , 14 ,LOW);

		//initiate external interrupt
		//MEXTI_voidInit(PA1,RISING_ENGE);
		//MEXTI_voidEnable(PA1);
		//initiate output pin
		//MDIO_INIT(PORTA);
		//MDIO_voidSetDirection(PORTA ,4 ,OUTPUT_10MHZ_PUSH_PULL);
		//MSYSTICK_voidInit();
		//MEXTI_voiddisable(PA1);
		//MEXTI_voidTriggerSW(PA1);
		MDIO_voidWrite_D_pin(PORTA , 4 ,HIGH);
		*/


		//MAFIO_voidInitAFIO();

		/*
		MNVIC_voidEnableInterrupt(TIM2_INT_NO);
		MTimer_voidInitMode(TIMER_2,UP_DOWN_TIMER);
		MTimer_voidEnableuSDelayInterrupt_once(TIMER_2,0xFF);
	*/



			//CLR_BIT(TIMER2->CR1,CMS1);
			//CLR_BIT(TIMER2->CR1,CMS0);

			//Update Enable to rise UIF
		  //   CLR_BIT(TIMER2->CR1,1);

			/*    PWM    */
			/*MRCC_voidInitClock();
			MRCC_voidEnableClock(RCC_APB1,0);
			MDIO_INIT(PORTA);
			MDIO_voidSetDirection(PORTA ,0 ,AF_10MHZ_PUSH_PULL);
			//enable up counting
			CLR_BIT(TIMER2->CR1,DIR);
			//enable timer2 auto reload
		    SET_BIT(TIMER2->CR1,ARPE);  //ARPE
		    //pre scaller
			TIMER2->PSC = 4;
			TIMER2->ARR  =255;
			//enable output pin
			SET_BIT(TIMER2->CCER,CC1E);
			SET_BIT(TIMER2->CCR1,OC1PE);
			//set the PWM mode to mode 1
			CLR_BIT(TIMER2->CCMR1,4);
			SET_BIT(TIMER2->CCMR1,5);
			SET_BIT(TIMER2->CCMR1,6);
			TIMER2->CCR1 =64;
			SET_BIT(TIMER2->EGR,UG);
			//enable timer
			SET_BIT(TIMER2->CR1,CEN);

*/
	//enable Output compare 1 pre load
		//	SET_BIT(TIMER2->CCMR1,3);

			//set as output channel
		//	CLR_BIT(TIMER2->CCMR1,0);
		//	CLR_BIT(TIMER2->CCMR1,1);

			//set polarity to active high
		//	CLR_BIT(TIMER2->CCER,1);
	/*PWM CODE*/
	/*MRCC_voidInitClock();
	MRCC_voidEnableClock(RCC_APB1,1);
	MDIO_INIT(PORTA);
	MDIO_INIT(PORTB);
	MDIO_voidSetDirection(PORTA ,6 ,AF_10MHZ_PUSH_PULL);
	MDIO_voidSetDirection(PORTA ,7 ,AF_10MHZ_PUSH_PULL);
	MDIO_voidSetDirection(PORTB ,0 ,AF_10MHZ_PUSH_PULL);
	MDIO_voidSetDirection(PORTB ,1 ,AF_10MHZ_PUSH_PULL);
	MTimer_voidInitMode(TIMER_3,PWM);
	MTIMER_SetPwm_CH_DutyCycle(0x10,TIMER_3,CHANNEL_1);
	MTIMER_SetPwm_CH_DutyCycle(0x7F,TIMER_3,CHANNEL_2);
	MTIMER_SetPwm_CH_DutyCycle(0x10,TIMER_3,CHANNEL_3);
	MTIMER_SetPwm_CH_DutyCycle(0x7F,TIMER_3,CHANNEL_4);
	*/
				MRCC_voidInitClock();
				MDIO_INIT(PORTA);
				MSYSTICK_voidInit();
				MDIO_voidSetDirection(PORTA ,2 ,OUTPUT_10MHZ_PUSH_PULL);
	/*Loop forever */

	for(;;){
		//MSPI_uint32EnableTranceive(SPI_1,0X5555);

		MDIO_voidWrite_D_pin(PORTA , 2 ,HIGH);
		MYSYSTICK_voidSet_BusyWait(0x4C4B40);
        MDIO_voidWrite_D_pin(PORTA , 2 ,LOW);
		MYSYSTICK_voidSet_BusyWait(0x4C4B40);

		/*
		    MTimer_voidIntiateuSDelayHold(TIMER_2,0xFFF5);
			MDIO_voidWrite_D_pin(PORTA , 1 ,HIGH);
			MTimer_voidIntiateuSDelayHold(TIMER_2,0xFFF5);
			MDIO_voidWrite_D_pin(PORTA , 1 ,LOW);
			*/
			/*TIMER2->CR1 &= ~(1<<7);	   //configure ARPE
			TIMER2->CR1 &= ~(1<<1);
			TIMER2->CR1 |=(1<<4);      //configure DIR as down counting
			TIMER2->PSC |= 0x8;       //SET PRESCALER TO 1
			TIMER2->ARR |=0xFF;        //SET INTERVAL
			TIMER2->DIER |=(1<<0);     //enable UIE interrupt
			TIMER2->CR1 |=(1<<0);      //enable CEN
			while(GET_BIT(TIMER2->SR,0) == 0);
			MDIO_voidWrite_D_pin(PORTA , 1 ,HIGH);

			TIMER2->CR1 &= ~(1<<7);	   //configure ARPE
			TIMER2->CR1 &= ~(1<<1);
			TIMER2->CR1 |=(1<<4);    //configure DIR as down counting
			TIMER2->PSC |= 8;       //SET PRESCALER TO 1
			TIMER2->ARR |=0xFF;     //SET INTERVAL
			TIMER2->CR1 |=(1<<0);    //enable CEN
			while(GET_BIT(TIMER2->SR,0) == 0);
			MDIO_voidWrite_D_pin(PORTA , 1,LOW);
	*/
	}
}
/*
void TIM2_IRQHandler(void){
	if(state==0){
	MDIO_voidWrite_D_pin(PORTA , 1 ,HIGH);
	state=1;
	}
	else if(state ==1){
	MDIO_voidWrite_D_pin(PORTA , 1 ,LOW);
	state=0;
	}
}*/
/*
void EXTI1_IRQHandler(void){
	MDIO_voidWrite_D_pin(PORTA , 4 ,HIGH);
}
*/
